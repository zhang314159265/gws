"""
Here is the prepare_softmax kernel inductor generates for gpt2: https://gist.github.com/shunting314/fe7d2482ed2d003545c6617def22a12d . It's perf:
        4.361ms    3.294GB    755.32GB/s
"""

from triton.testing import do_bench
import torch
import triton
import triton.language as tl
from torch._inductor.runtime import triton_helpers
from torch._inductor.runtime.triton_helpers import math as tl_math
from common import verify_numeric

def get_args():
    from torch._dynamo.testing import rand_strided
    # The shape is 50264 for the kernel generated by inductor. But using
    # 50257 is simpler and equivalent here.
    inp = rand_strided((32768, 50257), (50304, 1), device="cuda", dtype=torch.bfloat16)
    tmax = rand_strided((32768, 1), (1, 1), device="cuda", dtype=torch.float32)
    tsum = rand_strided((32768, 1), (1, 1), device="cuda", dtype=torch.float32)
    return inp, tmax, tsum

@triton.jit
def kernel(inp, tmax, tsum, xnumel, rnumel, XBLOCK: tl.constexpr, RBLOCK: tl.constexpr, ALT_LOOP_ORDER: tl.constexpr):
    xnumel = 32768
    rnumel = 50257

    xoffset = tl.program_id(0) * XBLOCK
    xindex = xoffset + tl.arange(0, XBLOCK)[:, None]
    xmask = tl.full([XBLOCK, RBLOCK], True, tl.int1)
    rbase = tl.arange(0, RBLOCK)[None, :]

    accmax = tl.full([XBLOCK, RBLOCK], float("-inf"), tl.float32)
    for roffset in range(0, rnumel, RBLOCK):
        rindex = roffset + rbase
        rmask = rindex < rnumel

        tmp0 = tl.load(inp + (rindex + 50304 * xindex), rmask, eviction_policy="evict_last", other=0.0).to(tl.float32)
        tmp2 = tl.broadcast_to(tmp0, [XBLOCK, RBLOCK])
        tmp4 = triton_helpers.maximum(accmax, tmp2)
        accmax = tl.where(rmask, tmp4, accmax)
    tmp3 = triton_helpers.max2(accmax, 1)[:, None]
    tl.store(tmax + (xindex), tmp3, None)

    accsum = tl.full([XBLOCK, RBLOCK], 0, tl.float32)
    if ALT_LOOP_ORDER:
        for roffset in range(rnumel - rnumel % RBLOCK, -RBLOCK, -RBLOCK):
            rindex = roffset + rbase
            rmask = rindex < rnumel
            tmp5 = tl.load(inp + (rindex + 50304 * xindex), rmask, eviction_policy="evict_first", other=0.0).to(tl.float32)
            tmp7 = tmp5 - tmp3
            tmp8 = tl_math.exp(tmp7)
            tmp9 = tl.broadcast_to(tmp8, [XBLOCK, RBLOCK])
            tmp11 = accsum + tmp9
            accsum = tl.where(rmask, tmp11, accsum)
    else:
        for roffset in range(0, rnumel, RBLOCK):
            rindex = roffset + rbase
            rmask = rindex < rnumel
            tmp5 = tl.load(inp + (rindex + 50304 * xindex), rmask, eviction_policy="evict_first", other=0.0).to(tl.float32)
            tmp7 = tmp5 - tmp3
            tmp8 = tl_math.exp(tmp7)
            tmp9 = tl.broadcast_to(tmp8, [XBLOCK, RBLOCK])
            tmp11 = accsum + tmp9
            accsum = tl.where(rmask, tmp11, accsum)
    tmp10 = tl.sum(accsum, 1)[:, None]
    tmp12 = tl_math.log(tmp10)
    tl.debug_barrier()
    tl.store(tsum + (xindex), tmp12, None)

def call(args, alt_loop_order=False):
    inp, tmax, tsum = args
    XBLOCK = 1
    RBLOCK = 2048
    num_warps = 16
    kernel[(triton.cdiv(inp.size(0), XBLOCK), )](inp, tmax, tsum, inp.size(0), inp.size(1), XBLOCK, RBLOCK, num_warps=num_warps, ALT_LOOP_ORDER=alt_loop_order)

if __name__ == "__main__":
    args = get_args() 
    ms = do_bench(lambda: call(args))
    print(f"{ms:.3f}ms")
    verify_numeric(*args)
    print("Pass the numerical check!")
